455. 分发饼干
已解答
简单
相关标签
相关企业
假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。

class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int child = 0,cookie = 0;
        while(child < g.length && cookie < s.length) {
            if(g[child] <= s[cookie]) child ++;
            cookie ++;
        }
        return child;
    }
}


135. 分发糖果
已解答
困难
相关标签
相关企业
n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

 

示例 1：

输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
示例 2：

输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。

class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] nums = new int[len];
        Arrays.fill(nums,1);
        for(int i = 1;i < len;i ++) {
            if(ratings[i] > ratings[i - 1]) {
                nums[i] = nums[i - 1] + 1;
            } 
        }
        int res = 0;
        for(int i = len - 1;i > 0;i --) {
            if(ratings[i] < ratings[i - 1]) {
                nums[i - 1] = Math.max(nums[i - 1],nums[i] + 1);
            }
            res += nums[i];
        }
        res += nums[0];
        return res;
    }
}

435. 无重叠区间
已解答
中等
相关标签
相关企业
给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

示例 1:

输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。

class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length == 0) return 0;

        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] arr1,int[] arr2) {
                return arr1[1] - arr2[1];
            }
        });

        int total = 0,prev = intervals[0][1];
        for(int i = 1;i < intervals.length;i ++) {
            if(intervals[i][0] < prev) {
                total++;
            } else {
                prev = intervals[i][1];
            }
        }
        return total;
    }
}

605. 种花问题
已解答
简单
相关标签
相关企业
假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。
示例 1：
输入：flowerbed = [1,0,0,0,1], n = 1
输出：true

示例 2：
输入：flowerbed = [1,0,0,0,1], n = 2
输出：false

class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for(int i = 0;i < flowerbed.length;i ++) {
            if((i == 0 || flowerbed[i - 1] == 0 ) && flowerbed[i] == 0 &&  (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {
                n -- ;
                flowerbed[i] = 1;
            }
        }
        return n <= 0;
    }
}


代码
测试用例
测试用例
测试结果
452. 用最少数量的箭引爆气球
已解答
中等
相关标签
相关企业
有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

 
示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。


class Solution {
    public int findMinArrowShots(int[][] points) {
        Arrays.sort(points,(arr1,arr2) -> Integer.compare(arr1[1],arr2[1]));
        int res = 0;
        for(int i = 0;i < points.length;i ++) {
            int maxRight = points[i][1];
            while(i < points.length && points[i][0] <= maxRight) {
                i ++;
            }
            res ++;
            i --;
        }
        return res;
    }
}
// 贪心策略： 找到右边的最大值，只要之后的左边值 <= 右边最大值，就都可以被一箭射中


 
