二分查找也常被称为二分法或者折半查找，每次查找时通过
将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。

搞不清楚如何定义区间开闭性
这里我提供两个小诀窍：
第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；
第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。


69. x 的平方根 
已解答
简单
相关标签
相关企业
提示
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。

class Solution {
    public int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}


154. 寻找旋转排序数组中的最小值 II
已解答
困难
相关标签
相关企业
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。

 

示例 1：

输入：nums = [1,3,5]
输出：1


class Solution {
    public int findMin(int[] nums) {
        int len = nums.length;
        int left = 0,right = len - 1;
        while(left < right) {
            int mid = (left + right) / 2;
            if(nums[mid] < nums[right]) {
                right = mid;
            } else if(nums[mid] > nums[right]){
                left = mid + 1;
            } else {
                right -= 1;
            }
        }
        return nums[left];
    }
}
// 二分查找：对于有序的数组，以log(n)的速度查找
// 1. 当中间值比右边值小时，说明右边必定是顺序的，要找最小的，右边就往左移动（为什么不是mid-1，可能会错过最小值）
// 2. 当中间值比右边值大时，说明最小值必定在右边，要找最小的，左边往右移动（为什么是mid + 1，最小的必定不会是中间值，跳过就行）
// 3. 可能中间值和右边一样大呢？那就忽略掉右边这一个数，-1
// 4.为什么不是left<=right，因为它会跳到最小值的后面一位


540. 有序数组中的单一元素
已解答
中等
相关标签
相关企业
给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

 

示例 1:

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: nums =  [3,3,7,7,10,11,11]
输出: 10

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int len = nums.length;
        if(len == 1) return nums[0];
        int left = 0,right = len - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == nums[mid ^ 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left];
    }
}
// 遇到相同的数，可以考虑用异或，相同数异或为0
// mid ^ 1 单数减一,双数加一
// 有成对相等的数,考虑异或
// 本来,只有双数时,基数索引是和左边相等;偶数索引是和右边相等

主要是控制好边界,以及左右指针赋值多少的问题:mid?mid-1?mid+1?
